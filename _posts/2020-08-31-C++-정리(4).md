---
title: C++ 정리(4)
excerpt: "이 글에서는 C++의 STL 내용들 중, 메모해둘만 한 것들을 기록하려고 합니다."
toc: true
toc_sticky: false
toc_label: 포스트 주요 목차

categories:
 - language
tags:
 - C++


last_modified_at: 2020-08-22T20:37-05:00
---

4번 글은 STL 관련 메모입니다.
제가 보려고 하는 거라서 큰 쓸모가 없을 수 있습니다.

---



## <컨테이너>

### Vector

* Iterator

  ```Vector``` 클래스 템플릿 내에 ```typedef```로 선언되어있는 듯. ```std::vector<T>::iterator```로 접근 가능. 

  1. ```begin()``` : 첫 원소 가리키는 반복자
  2. ```end()``` : 마지막 원소의 다음 공간을 가리키는 반복자
  3. ```cbegin()```, ```cend()``` : 값에 접근만 하는 const_iterator 전용 
  4. ```rbegin()```, ```rend()``` : 역순으로 벡터 접근. ```vector```의 index는 ```unsigned int```를 쓰기 때문에 [ ] 연산자로 역순 접근 불가능. (0 다음에 오버플로우)

* ```insert``` , ```erase```

  1. ```insert(iterator , value)``` : iterator 위치에 value를 넣음. 

  2. ```erase(iterator)``` : iterator 위치를 지움. iterator 두 개를 받는다면 해당 구간을 지움.

     

  둘 다 O(n).

  **insert, erase를 사용하면 기존의 iterator들은 모두 무효화됨.**
  
  그래서 쓰는 방법이, ```remove```함수를 ```erase```에 물려서 쓰는 편법.
  
  ```remove```함수는 주어진 범위 내에서 특정 값의 원소 자리에 다음 칸 원소의 값을 덮어 씌워 마치 삭제하는 것처럼 동작한다. 
  
  ```remove(vec.begin(), vec.end(), 3)```을 한다면,
  
  <u>5</u> 1 3 2 4 3 5
  
  5 <u>1</u> 3 2 4 3 5
  
  5 1 <u>2</u> 2 4 3 5		3을 찾았으니 계속해서 원소를 한 칸씩 당김
  
  5 1 2 <u>4</u> 4 3 5		
  
  5 1 2 4 <u>4</u> 3 5		당기려고 봤더니 3이네? 다른 값 찾을 때까지 보류
  
  5 1 2 4 4 <u>3</u> 5		3은 무시
  
  5 1 2 4 5 3 <u>5</u>		끝에 도달했고, 3이 아닌 값이니 얘를 앞에 덮어 씌우고 종료.
  
  
  
  마지막 하나의 원소는 지우고 싶은 값을 갖고 있는 채로 끝나게 되는데, 그 자리를 가리키는 반복자를 반환한다. 따라서 그 반복자에 ```end()```를 물려서 ```erase```함수를 쓰면 된다. 그럼 불필요한 원소들을 모두 삭제할 수 있다.
  
  따라서 
  
  ```cpp
  vec.erase(remove(vec.begin(), vec.end(), 3), vec.end());
  ```
  
  를 하면 된다.
  
  
  
  특정 값이 아니라 어떤 조건에 맞는 원소들을 지우고 싶다면 ```remove_if```함수를 사용하면 된다. 세번째 인자로 조건에 해당하는 함수 / 함수 객체를 주면 됩니다.



### List

* Iterator

  ```BidirectionalIterator```임. 따라서 ++, -- 연산 밖에 쓸 수 없음. 

  ```insert```, ```erase``` 함수를 사용해도 반복자가 무효화 되지 않음.



### Deque

​	블록 별로 데이터를 저장. 벡터처럼 데이터가 연속되어 들어있지 않음.
​	대신 ```insert```, ```delete```, random access, 전부 가능. push/pop_back/front 모두 가능.



### Set

​	컨테이너 안에 데이터가 있는지 확인하는 용도로 사용.

* 멤버 함수

  1. ```insert```: 데이터를 컨테이너에 입력. 중복은 알아서 없어짐.

  2. ```erase```: 해당 값의 데이터 삭제.

  3. ```find```: 데이터가 있는지 찾음. 

     ​		있으면 해당 데이터를 가리키를 반복자를 , 없으면 ```end()```를 return.

  

  ```begin()```에서부터 출력해보면, 데이터가 정렬되어 있음을 알 수 있음. Red-black tree를 사용한 내부 구조를 갖는다고 함. ~~(알고리즘 다른 교수님 강의를 들어야겠다..!)~~

템플릿 인자로 내가 만든 클래스를 넣고 싶으면 ```operator<```를 만들어줘야함. ```cmp```클래스(struct)를 만들어서 같이 주던지.



### Map

key와 value로 이루어진 ```pair```를 데이터로 받음.
```insert``` 함수의 파라미터가 ```pair```임. 타입 지정해서 ```std::pair<T1, T2>(a, b)``` 하던지, ```make_pair```함수를 쓰면 됨. ```insert```를 쓰지 않는다면 ```map[Key] = value```형식으로 원소 추가 가능.

​	```Map```의 Key 하나가 여러 개의 value를 가리킬 수 없음. 

		1. ```Insert```는 먼저 들어온 value를 우선시함. 나중에 ```insert```된 것은 무시.
  		2. ```[]```는 나중에 들어온 ```value```를 우선시함. 따라서 어떤  Key에 해당하는 값을 바꾸고 싶다면 ```[]```연산자를 사용.

템플릿 인자로 내가 만든 클래스를 넣고 싶으면 ```operator<```를 만들어줘야함. ```cmp```클래스(struct)를 만들어서 같이 주던지.



### Multiset, Multimap

중복을 허용하는 set과 map.

Multimap의 경우, ```[]```연산자를 쓰면 해당 key에 붙어있는 여러 value들 중 아무거나 임의의 것이 하나 나옴. 명확한 기준이 없음.

해당 key에 붙은 value들을 모두 알고 싶다면 ```equal_range(KEY)```함수를 쓰면 됨. 
return 값으로 KEY를 키로 가지는 반복자들의 시작과 끝을 ```pair```로 만들어서 줌. 



### 