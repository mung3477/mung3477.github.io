---
title: 2231_분해합
excerpt: "백준 2231번, 분해합 문제입니다."
categories: 
 - PS
tags:
 - PS
 - BOJ
 - Brute force
last_modified_at: 2020-07-11T11:53-05:00
---

백준 2231번, [분해합](https://www.acmicpc.net/problem/2231) 문제입니다.

kks227님의 네이버 블로그 대회알고리즘 카테고리를 역순으로 하나하나 읽으면서 문제를 풀려고 합니다. 역시 교재가 있어야죠!

```cpp
#include <cstdio>

/*
분해합이 N인 제일 작은 M 찾기.
N의 생성자 : N ~ N - 9 * 자리수 중 하나.
자리수가 1 ~ 7 이니까 63개만 보면 됨. brute force!
*/


//////////////////////////////////////////////////
int decomp_sum(int K);
int digit(int N);

//////////////////////////////////////////////////
int main(void)
{
    int N, M, K;
    scanf(" %d", &N);
    
    K = N - 9 * digit(N);
    for(K; K <= N; K++){
        if(decomp_sum(K) == N) break;
    }
    if(K == N + 1) {
        printf("0");
    }
    else{
        printf("%d", K);
    }
    return 0;
}

int digit(int N)
{
    int digit = 0;
    for(N; N; N /= 10){
        digit++;
    }
    return digit;
}

int decomp_sum(int K)
{
    int decomp_sum = K;
    for(K; K; K /= 10){
        decomp_sum += K % 10;
    }
    return decomp_sum;
}
```



N의 **부분합**이란, N이 234인 경우 234 + 2 + 3 + 4 = 243 처럼 그 숫자에 각 자리의 수를 더해서 계산합니다. 부분합이 243인 숫자 M은 243의 **생성자** 라고 합니다.

우리는 부분합 N이 주어졌을 때 N의 생성자 중 가장 작은 수를 구해야합니다. 생성자가 없으면 0을 출력합니다. 

가장 간단하게, 각 자리 숫자가 9인 경우 기존의 숫자에서 가장 멀리 떨어진 생성자가 될 것이라고 생각했습니다. 117 = 99 + 9 + 9처럼요. 그래서 117 - 9 -9 부터 시작했습니다. 사실은 자리수 만큼 9를 빼주고 시작했으니 9를 한 번 더 뺐습니다. 어차피 9 더 빼봐야 9번 더 계산하는 건데, 그냥 자리수만큼 9를 빼버렸습니다.  그럼 **9 * 자리수** 만큼 탐색해야하는데, 최대 1,000,000을 입력받으니 최악의 경우 63번 탐색합니다. 탐색 공간의 크기가 매우 작으니 brute force를 사용했습니다.

작은 숫자부터 시작했으니 처음 마주하는 생성자를 답으로 채택하여 즉시 탐색을 중단했습니다.



