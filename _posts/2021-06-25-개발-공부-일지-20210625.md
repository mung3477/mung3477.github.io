---
title: "2021-06-25 개발 공부 일지"
excerpt: "메멘토 방지용 개발 공부 기록"
categories:
  - Develop
tags:
  - React
last_modified_at: 2021-06-25
---

* 06/25

  프로젝트장 친구가 PR을 요청해서 읽었다.

  클립보드 관련해서 변동 사항이 있었다. 뭐 읽으니까 이해가 가긴 하는데, 몇 가지 이유나 원리가 이해 안 가는게 있었다. 그걸 이해 못하는 이유는 내가 클립보드 부분의 전반적인 돌아가는 방식을 이해하지 못하기 때문인 것 같다. 그래서 이 글에서는 우리 프로젝트에서 어떻게 클립보드 부분이 구동되는지 정리하려고 한다. 

  겸사 겸사 일렉트론의 main / renderer도 다시 정리하고, 전반적인 이해 수준을 높일 수 있을 것 같다.



<h4>Asynchronous Javascript</h4>

우선 Asynchronous / Synchronous를 짚고 넘어가자. callback들이 어떻게 실행되는지 명확히 짚고 넘어갈 필요가 있다. 마침 좋은 글을 찾기도 해서.

원래 synchronous 한 프로그래밍 언어들은 Call stack을 이용해 함수의 실행을 처리한다.

```javascript
const second = () => {
  console.log('Hello there!');
}

const first = () => {
  console.log('Hi there!');
  second();
  console.log('The End');
}

first();
```



![img](https://miro.medium.com/max/2514/1*DkG1a8f7rdl0GxM0ly4P7w.png)



그런데 이 방식만으로는 문제가 있다. 

만약 네트워크에서 많은 데이터를 받아오는 함수가 중간에 껴있다면? 
전체 프로그램의 동작이 멈추게 된다. 

이런 문제들을 해결하려는 과정이 Asynchronous Javascript가 만들어진 동기다.

다음은 Javascript Engine의 런타임 환경이다. 

![img](https://miro.medium.com/max/1049/1*O_H6XRaDX9FaC4Q9viiRAA.png)

Event loop이나 web API, message queue는 JS Engine은 아니지만, 브라우저 또는 NodeJS의 런타임 환경에 들어있는 구성요소들이다. 

```javascript
const networkRequest = () => {
  setTimeout(() => {
    console.log('Async Code');
  }, 2000);
};console.log('Hello World');networkRequest();console.log('The End');
```

![img](https://miro.medium.com/max/1053/1*sOz5cj-_Jjv23njWg_-uGA.gif)

위 코드를 실행하면 다음과 같은 과정을 거친다. 

networkRequest에서 setTimeout을 호출하는데, 이는 web API 쪽에 타이머를 설치한다.

타이머가 끝나면 붙어있던 callback 함수가 message queue에 들어가서 call stack이 비어있길 기다린다. 원하던 기회가 찾아오면 callback 함수는 call stack에 올라가고, 다른 함수들처럼 실행된다. **Event listener들은 web API 자리에 들어가고, 해당 이벤트가 발생하면 연결된 callback 함수가 message queue에 올라간다.** 

ES6부터 Javascript의 promise가 사용하는 job/micro-task queue가 생겼다. 이 queue는 message queue보다 우선순위를 가진다. 



<h4>일렉트론의 Main과 Renderer</h4>

두번째로 일렉트론부터 명확하게 이해하고 가자. Main이랑 Renderer로 구성되어 있다는 것은 아는데, 정확히 이들이 무엇을 의미하는 지는 모르겠다.

일렉트론을 구동시키면 main 프로세스가 생성된다. NodeJS와 OS의 native GUI에 접근하여 애플리케이션의 GUI를 만든다. 

main 프로세스에서 BrowserWindow라는 모듈을 이용해 win 객체(어플리케이션 창)을 만드는데, 이 win이 renderer 프로세스를 생성한다. renderer 프로세스는 HTML로 코딩되어 있고, CSS나 JS 같은 것들을 불러옴으로써 창이 보여지게 된다.

각 win 객체는 어플리케이션 창을 독립적으로 render한다.

우리 프로젝트에서는 main이 background와 main이라는 이름의 BrowserWindow 객체를 만든다. 각각의 win 객체는 renderer를 React로 구동시켜 창을 그려낸다.

두 프로세스는 IPC(Inter Process Communication)이라는 통신 모듈을 사용해 서로 대화한다. main 프로세스는 ipcMain 모듈을, renderer 프로세스는 ipcRenderer 모듈을 써서 메세지 전달 / 응답이 가능하다. 





<hr>

<h4>참고자료</h4>

* https://kay0426.tistory.com/17
* https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff



