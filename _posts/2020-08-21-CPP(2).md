---
title: C++ 정리(2)
excerpt: "이 글에서는 C++의 기초적인 내용들 중, 메모해둘만 한 기능들을 기록하려고 합니다."
toc: true
toc_sticky: false
toc_label: 포스트 주요 목차

categories:
 - language
tags:
 - C++


last_modified_at: 2020-08-21T20:37-05:00
---

[1번 글](https://mung3477.github.io/language/CPP(1)/)에 이어서, 2번 글에서는 C++의 객체 지향 프로그래밍 특징을 다룹니다. 



## 클래스

클래스도 하나의 자료구조입니다. 접근 가능 범위와 함수를 멤버로 가질 수 있다는 점이 struct와의 차별점입니다.

```cpp
class class_이름 {
    access_specifier_1:
    	member1;
    access_specifier_2:
    	member2;
    ...
} object_이름1, object_이름2, ... ;
```

선언 형태는 위와 같습니다.

* #### 접근 지정자 (Access specifier)

  *private, protected, public* 중 하나를 사용합니다. 
  *private*은 동일 클래스 내 / friend 관계에서 접근 가능합니다.
  *protected*은 동일 클래스 내 / friend / 해당 클래스를 상속하는 클래스에서 접근 가능합니다.
  *public*은 어디서든 접근 가능합니다.
  접근 지정자를 쓰지 않으면 기본인 private로 설정됩니다.

  

```cpp
class CRectangle {
    	int x, y;
    public:
    	void set_values(int, int);
    	int area () { return (x * y); }
};
```

위 코드로 CRectangle 클래스를 만들었습니다. private 멤버인 x, y와 public 멤버인 두 함수를 가지고 있습니다.
함수는 set_values 처럼 프로토타입만 써둘 수도 있고, area처럼 구현해두어도 됩니다.

set_values 함수를 정의하려면 다음과 같이 **범위 연산자(::)**를 사용하면 됩니다.

```cpp
void CRectangle::set_values (int a, int b) {
    x = a;
    y = b;
}
```

CRectangle 클래스에 속한 함수라고 명시해주었으므로, CRectangle 클래스의 private 변수인 x, y에 접근할 수 있습니다. 



* #### 생성자 (constructor)

  ```cpp
  int main(void) {
  	CRectangle rect, rectb;
  }
  ```

  rect와 rectb라는 객체를 만들었습니다. 아직 rect.x, rect.y, rectb.x, rectb.y는 초기화 되어있지 않은데요. 여기서 area 함수를 호출하게 되면 문제가 발생하겠죠. 따라서 클래스로 객체를 만들 때, 객체를 초기화하게끔 함수를 만들어주어야 합니다. 이 함수를 **생성자**라고 하는데요. 생성자의 규칙은 두 가지 입니다.

  1. 클래스와 이름이 동일하다.

  2. return 형이 없다. (void도 안됨)

     

  그럼 CRectangle에 생성자를 만들어줍시다.

  ```cpp
  class CRectangle {
      	int x, y;
      public:
      	CRectangle(int, int);
      	int area() { return (x * y); }
  };
  
  CRectangle::CRectangle(int a, int b) {
      x = a;
      y = b;
  }
  ```

  set_values가 했던 일을 생성자로 한 번에 처리해줬습니다. 생성자 역시 하나의 함수이니, 함수 프로토타입 & 구현 방식에 맞춰서 만들어줍니다.

  

* #### 소멸자 (destructor)

  소멸자는 생성자와 하는 일이 반대입니다. 객체의 사용이 끝나서 객체가 사라지는 경우 (존재 범위 종료(Ex. 함수 호출 종료), 동적 할당 해제 등)에 자동적으로 호출되는 함수입니다. 소멸자도 규칙이 2가지입니다.

  1. 클래스와 이름이 동일하되, 이름 앞에 **~**를 붙일 것.
  2. return 값이 없다(void도 안됨).

  위에 들은 예시 중 동적 할당의 경우에 소멸자를 쓰면 매우 편리합니다.

  

  그럼 CRectangle을 조금 변형하고, 소멸자를 만들어줍시다.

  ```cpp
  class CRectangle {
      	int *x, y;
      public:
      	CRectangle(int, int);
      	~CRectangle();
      	int area() { return (*x * *y); }
  };
  
  CRectangle::CRectangle(int a, int b) {
      x = new int;
      y = new int;
      *x = a;
      *y = b;
  }
  
  CRectangle::~CRectangle() {
      delete x;
      delete y;
  }
  ```



* #### 생성자 오버로딩

  함수를 오버로딩 했듯이, 생성자도 함수이므로 오버로딩이  가능합니다.
  같은 이름, 다른 함수 인자를 가지면 되겠죠.

  ```cpp
  class CRectangle {
      	int x, y;
      public:
      	CRectangle();
      	CRectangle(int, int);
      	int area() { return (x * y); }
  };
  
  CRectangle::CRectangle() {
      x = 5;
      y = 5;
  }
  
  CRectangle::CRectangle(int a, int b) {
      x = a;
      y = b;
  }
  ```

  아무런 인자를 갖지 않는 생성자를 만들었습니다. x, y의 기본값을 설정하는 용도로 아주 적합합니다.
  이런 생성자를 <u>**기본 생성자**</u>(default constructor)라고 하는데요. 프로그래머가 생성자를 하나도 정의하지 않은 경우, 컴파일러가 알아서 기본 생성자를 만들어줍니다. 아무 역할도 하지 않지만, 그저 객체를 만들기 위한 함수죠. 이 때문에 생성자를 만들지 않아도 아까 위에서 봤던

  ```cpp
  int main(void) {
  	CRectangle rect, rectb;
  }
  ```

  이런 식의 객체 정의가 가능했던 것입니다. 자동으로 생성된 기본 생성자를 이용한 것이죠.

  다만, 기본 생성자를 사용할 때 주의 할 점은 **()**를 끝에 붙이면 안된다는 점입니다. 

  ```cpp
  CRectangle rect(3, 4); 	//는 됩니다.
  CRectangle rect(); 		//는 안 되지만,
  CRectangle rect;   		//는 됩니다.
  ```

  기본 생성자 이외의 다른 생성자를 만든 경우 기본 생성자가 자동으로 만들어지지 않으니, 기본 생성자를 만드는 습관을 들이면 좋습니다.

  

* #### 복제 생성자 (Copy constructor)

  기본 생성자 이외에도 언어 내부적으로 만들어져있는 생성자가 있습니다. 복제 생성자인데요. 객체 B에 객체 A를 그대로 옮기는 연산입니다.

  ```cpp
  CExcample::CExample (const CExample& rv) {
      a = rv.a; b = rv.b; c = rv.c;
  }
  ```

  이런 느낌입니다. 생성자의 인자로 그 클래스 객체를 넣어주면 됩니다. ```CExample ex2 (ex)```처럼요.



막상 알고 보니 클래스와 struct는 꽤 닮았습니다. 실제로, struct도 함수를 멤버로 가질 수 있습니다. 다만, 접근 지정자의 사용 가능 유무가 차이죠. struct는 전부 public 상태입니다. 



* #### 연산자 오버로딩

  두 클래스를 더하고 싶으면 어떻게 해야 할까요? C라면 새로운 add 함수가 필요했습니다. C++에서는, +같은 기본 연산자들을 오버로딩해서 사용할 수 있습니다. 정확히는 연산자 함수를 오버로딩 하는데요.

  CRectangle 두 개를 더하는 + 연산자를 만들어봅시다.

  ```cpp
  class CRectangle {
      	int x, y;
      public:
      	CRectangle();
      	CRectangle(int, int);
      	int area() { return (x * y); }
  };
  
  CRectangle::CRectangle() {
      x = 5;
      y = 5;
  }
  
  CRectangle::CRectangle(int a, int b) {
      x = a;
      y = b;
  }
  
  CRectangle CRectangle::operator+ (CRectangle param) {
      CRectangle temp;
      temp.x = x + param.x;
      temp.y = y + param.y;
      return temp;
  }
  ```

  생성자와 다르게, operator 함수는 해당 클래스 객체를 return 값으로 가집니다. A + B = C를 생각해보면 당연합니다.
  이후로 두 CRectangle 객체를 더하려면

  ```cpp
  rect3 = rect2 + rect1;
  rect3 = rect2.operator+(rect1);
  ```

  둘 다 가능합니다.

  

  복제 생성자와 같이, **복제 연산자(=)** 또한 C++에 생성되어 있습니다.

  ```cpp
  CRectangle rect1 (2, 3);
  CRectangle rect2;
  rect2 = rect1;
  ```

  이것도 올바른 표현입니다. 복제 연산자가 유일하게 자동으로 만들어지는 연산자 함수입니다.



* #### this

  this는 **"지금 이 객체" 를 나타내는 <u>포인터</u>**를 의미합니다.
  좋은 예시로는 복제 연산자 함수를 들 수 있습니다. 보통 이렇게 정의된다고 합니다.

  ```cpp
  CRectangle& CRectangle::operator= (const CRectangle& param) {
      x = param.x;
      y = param.y;
      return *this;
  }
  ```

  위처럼 레퍼런스와 함께 묶어서 사용하면 좋습니다.



* Static 멤버

  static 멤버는 해당 클래스의 모든 객체들이 공유하는 멤버입니다.  그 클래스를 이용해 만든 객체라면 모두 동일한 값을 가집니다.

  ```cpp
  class CDummy {
      public:
      	static int n;
      	CDummy () { n++; };
      	~CDummy () { n--; };
  };
  
  int CDummy::n = 0;
  
  int main(void){...}
  ```

  static 멤버는 여러 번 정의되는 것을 막기 위해 클래스 내에는 프로토타입만 만들고, global 지역에서 정의합니다. 위 n은 클래스 객체의 수를 세기 위해 사용했습니다. static 멤버는 다른 멤버와 달리 객체 이름이 아니라 클래스 이름으로 접근이 가능합니다. ```CDummy::n```처럼요.

  당연히 함수도 static 멤버가 될 수 있습니다. 단 static 함수는 static 변수들만 사용할 수 있고, ```this```를 사용할 수 없습니다. ```this```는 객체에 대한 포인터인데 static 함수는 클래스의 멤버일 뿐, 객체의 멤버가 아니기 때문입니다.